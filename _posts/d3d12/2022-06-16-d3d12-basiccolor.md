---
title: "D3D 컴퓨터 기본 색상"

categories:
  - D3D12


tags:
  - d3d12
  - basic computer color

toc: true
toc_label: Basic Computer Color
toc_sticky: true

sidebar_main: true
---

컴퓨터 모니터틑 픽셀마다 적녹청 빛을 섞어서 방출합니다. 색상의 조합, 빛의 세기를 잘 섞음으로써 필요한 모든 색상을 묘사할 수 있습니다.

적녹청을 채널을 통칭해 RGB 라고 합니다. 모니터의 RGB의 세기에는 상한이 존재합니다. 빛의 세기를 나타날 떄에는 0~1 까지 정규화된 값을 쓰는 것이 편리합니다. 0은 빛이 전혀 없는것이고 1은 빛의 세기가 최대인 상황입니다. 예를 들어(0.25, 0.67, 1.0)은 25%의 적색광, 67%의 녹색광, 100% 세기의 청색광의 혼합입니다. 또 하나의 색상을 3차원 벡터로 나타낼 수 있음을 알려줍니다. rgb는 각각 혼합색의 세기이고 $0 \leq r,g,b \leq 1$ 입니다.

<br/>

# 색상 연산

일부 벡터 연산은 색상 벡터에도 적용된다. 두 색상을 더해서 새로운 색상을 얻거나 <br/>

$ (0, 0.5, 0) + (0, 0, 0.25) = (0, 0.5, 0.25)$

두 색상을 빼서 새로운 색상을 얻을 수 있다.

$ (1, 1, 1) - (1, 1, 0) = (0, 0, 1) $

스칼라 곱셈도 의미가 있다.

$ 0.5(1, 1, 1) = (0.5, 0.5, 0.5) $

한편 내적이나 외적 같은 연산은 별 의미가 없다. 다만, 색상 벡터만의 연산도 있는데 변조(modulation) 이라고 하는 성분별 곱셈이 바로 그것이다.

$ (C_r, C_g, C_b) \otimes (k_r, k_g, k_b) = (C_r k_r, C_g k_g, C_b k_b)$

주로 조명 공식에 쓰인다. 예를 들어 표면의 입자광선이 적색광을 50%, 녹색광을 75%, 청색광을 25% 반사한고 나머지는 흡수한다. 그렇다면 표면에 반사된 광선의 색은 

$ (r, g, b) \otimes (0.5, 0.75, 0.25) = (0.5r, 0.75g, 0.25b)$

이다.

색 연산을 수행하다 보면 0~1 구간을 나갈 수 있다. 1보다 더 큰 성분으 나오면 안되니 1로 보정을 해야한다 이렇게 특정 구간을 벗어나지 않도록 하는 것을 clamping 이라고 부른다.

<br/>

# 128 비트 색상

그래픽 응용 프로그램에서 색을 다룰 때 흔히 적 녹 청 녹 외 알파라고 부르는 성분 하나를 색상 벡터에 도입한다. 주로 알파는 색상의 불투명도를 나타내는 데 쓰인다. 불투명도는 색상 혼합에 유용하다. 알파를 도입한다는 것은 하나의 색상을 4차원 벡터로 표현하는 것을 의미한다. 여기서 $0 \leq r, g, b, a \leq 1$ 이고 각 성분이 32비트 부동소수점 하나라면 128비트가 필요하다. 수학적으로 색상은 4차원 벡터이닌까 XMVECTOR 형식으로 색상을 표현할 수 있다. 그렇다면 DirectXMath 라이브러리의 벡터 함수로 색상 연산을 하면 SIMD 의 혜택을 받게된다. 성분별 곱셈은 XMColorModulate 로 수행한다.

<br/>

# 32 비트 색상

각 성분을 8비트로 할당해서 하나의 색상을 32비트로 표현할 수 있다. 8비트이기에 한 성분에 총 256가지의 세기를 표현할 수 있다. 색상 성분당 1바이트닌까 256의 3승 = 16777216 이닌까 넉넉하다. DirectXMath 라이브러리는 32비트 색상의 저장을 위해 다음과 같은 [XMCOLOR](https://docs.microsoft.com/en-us/windows/win32/api/directxpackedvector/ns-directxpackedvector-xmcolor) 구조체를 사용한다.

정수 구간 0~255 를 0~1로 변환함으로써 32비트 색상을 127비트로 변환하는 것이 가능하다. $0 \leq n \leq 255$ 일때 $0 \leq \frac{n}{255} \leq 1$ 로 정규화한다. 아래는 32비트 색상을 127비트로 정규화한 예이다.

$(80, 140, 200, 255) \Rightarrow (\frac{80}{255}, \frac{140}{255}, \frac{200}{255}, \frac{255}{255}) \approx (0.31, 0.55, 0.78, 1.0)$

그런데 일반적으로 32비트 색상은 8비트 색상 성분 네 개를 하나의 32비트 정수 값으로 채워넣은 packed 형태이기에 32비트 색상을 128로 변경하려면 추가적인 비트 연산이 필요하다. XMCOLOR 가 실제로 그런 32빝 ㅡ색상인데 DirectXMath 라이브러리는 XMCOLOR 를 하나 받아서 XMVECTOR 를 돌려주는 XMLoadColor 메소드를 제공한다. XMCOLOR 는 ARGB 배치를 사용하니 DirectXMath 라이브러리에는 XMVECTOR 색상을 XMCOLOR 로 변환하는 XMStoreColor 메소드도 존재한다.

대체로 128비트 색상은 정밀도 높은 색상 연산이 필요한 픽셀 셰이더 등에 쓰인다. 그러나 최종 픽셀 색상은 일반적으로 후면 버퍼 32비트 색상으로 저장된다.

<br/>

