---
title: "소프트웨어 구조"

categories:
  - GPP


tags:
  - gameprogrammingpattern
  - oop
  - intro

toc: true
toc_label: Intro
toc_sticky: true

sidebar_main: true
---

모든 프로그램, 심지어 `main` 함수에 전부 떄려박은 코드에도 어떤 식으로든 구조가 있다. 그렇다면, 좋은 구조와 나쁜 구조를 어떻게 구별 할 수 있을까?

<br/>

# 좋은 소프트웨어 구조

`뭔가를 고쳐야 할 때 그럴 줄 알았다는 듯이 코드가 준비되어 있어 적당한 함수 며 개만 호출하면 원하는 작업을 할 수 있다` 라는 게 말이 쉽지 현실적으로 쉽지 않다.

**구조에 대한 고민은 변경과 관련이 있다. 얼마나 쉽게 변경할 수 있느냐가 코드 설계를 평가하는 척도가 된다.** 

<br/>

## 코드를 고치는 방법

코드를 고치려면 관련된 부분을 머릿속에 넣어야 한다. 또한 이 과정이 가장 오래걸린다.

머릿속에 코드를 그리면 해결책을 어렵지 않게 찾을 수 있다. 이 과정은 비교적 수월하고 실제 코딩은 생각보다 별 것 아닌 경우가 종종 있다.

컴파일되고 작동한다고 아직 끝난게 아니고 테스트를 작성하고, 코드 리뷰 전에 코드를 정리해야 한다.

이제 추가한 코드들을 깔끔하게 통합하기 위해 어느정도 잘 맞춰줘야한다. 그러면 다른 사람들은 바뀌었는 지도 모를 것이다!

<br/>

## 디커플링의 장점

양 쪽 코드 중에 한쪽이 없으면 코드를 이해할 수 없을 때 커플링이 되어 있다고 본다. 두 코드를 디커플링 하면 따로따로 이해할 수 있다. 작업해야 할 코드가 한쪽 코드에만 관련 있다면 한쪽 코드만 머리에 넣으면 된다.

**작업에 들어가기 전에 알아야 할 지식의 양을 줄이는 것** 이 이 책에서 생각하는 소프트웨어 구조의 핵심 목표이다.

<br/>

# 비용

모든 구조를 다 디커플링하면 추후 개발도 쓱쓱만 해도 뚝딱 나올것이다. 말이 참 쉽다.

이 목표를 이루기 위해 추상화, 모듈화, 디자인 패턴, 소프트웨어 구조에 열광한다. 좋은 구조는 생산력을 크게 높여준다.

하지만 그냥 되는 건 아니다. 좋은 구조를 위해선 더 많은 노력과 원칙이 필요하다. 기능을 하나 추가하거나 조금 바꿀 때 마다 나머지 코드와 깔끔하게 통합될 수 있도록 노력해야한다.

다들, 구조에 제약이 없고, 확장하기 쉬운 코드베이스, 다시말해 `강력한 만능 게임 엔진`을 원한다. 그렇기에 어디서 디커플링하고 추상화할지, 어느 부분에서 확장성 있게 설계할지도 정해야 한다.

여기서부터 어려워지는데 추상화 계층을 추가하거나 확장 가능성을 제공하는 것은 나중에 필요할 것 이라고 **예측** 했기 때문이다. 이것을 위해 코드를 추가하고, 복잡성을 늘리는 것은 개발 기간이 길어지게 된다.

예측이 잘 맞아 떨어져서 코드를 수정할 일이 생긴다면 노력에 대한 보상을 받을 수 있다. 하지만 미래를 예측을 하는 것은 어렵다. 기껏 만들고 써먹지 못하면 작업해야할 코드만 늘어났으니 안만드니만 못하다.(YANGI : You Aren't Gonna Need It)

보조 코드가 늘어나면 실제 작업 코드를 찾는 건 더 오래 걸리게 된다. 뭔가 변경 해야 한다면, 도움 될 만한 인터페이스가 어딘가엔 있겠지만 찾기가 어렵다. 이론대로라면 디커플링된 코드가 이해해야 하는 코드 양을 줄여줘야 했겠지만, 오히려 추상화 계층 때문에 더 복잡해져버렷다.

<br/>

# 성능과 속도

소프트웨어 구조와 추상화가 성능을 저하시킨다는 비판도 잇다. 가상 함수, 인터페이스, 추상화, 포인터, 메시지 같은 메커니즘은 어느정도 런타임 비용을 요구한다.

여기에는 이유가 있다. 소프트웨어 구조는 코드를 유연하고 쉽게 변경할 수 있게 만들기 위해 존재한다. 인터페이스를 사용하는 이유는 같은 인터페이스를 구현하는 어떤 클래스가 와도 코드가 문제없이 동작 되도록 하기 위함이다. 

성능은 전부 가정에 기반한다. 최적화 기법은 구체적인 제한을 선호한다. 종류가 256가지 이하라면 1Byte 로 압축할 수 있다. 한 자료형의 한 메소드만 호출한다면 인라인으로 작성할 수 있다.

유연성이 좋아야 게임을 쉽게 변경할 수 있고 개발 속도는 게임 재미를 찾는데 꼭 필요하다.

프로그램을 유연하게 만들면 성능상의 비용이 발생하지만 반대로 코드를 최적화하면 유연성이 떨어진다.

<br/>

# 나쁜 코드의 장점

엉성한 코드도 나름의 가치는 있다.

구조화된 코드를 작성하기 위해선 많은 시간이 필요하다. 더 좋은 구조를 개발 기간 내에 유지하려면 더 많은 노력이 필요하다.

기획 확인에 필요한 기능만 돌아가도록 대강 코드를 작성하는 프로토타이핑 기법은 적법한 프로그래밍 실천법이다. 하지만, 버릴 코드는 확실히 버릴 수 있어야 한다.

<br/>

# 균형 잡기

우리에게는 다음과 같은 목표가 있다.

1. 프로젝트 개발 기간 동안 코드를 쉽게 이해할 수 있도록 구조를 깔끔하게 만들고 싶다.
2. 실행 성능을 최적화 하고 싶다.
3. 지금 개발 중인 기능을 최대한 빠르게 구현하고 싶다.

이 목표들은 어느정도 서로 상반된다. 좋은 구조는 장기적으로 생산성을 높여주지만, 좋은 구조를 유지하는 것은 더 많은 시간을 필요로 한다.

최대한 빠르게 구현한 결과물이 최고의 실행 속도를 내는 경우는 드물다. 최적화에는 엄청난 개발 기간이 소요된다. 최적화 후에는 코드가 고착화 되는 경향이 있다. 극도로 최적화된 코드는 유연하지 않고 고치기가 어렵다.

기능을 최대한 빨리 밀어넣다 보면 버그가 늘고 일관성이 없어지고 생산성이 떨어진다.

각각은 장단점이 있기 떄문에 명쾌한 정답이 없고 어느정도의 타협만 있을 뿐이다. "정답은 없고 오답에 대한 다양한 취향이 있을 뿐이다"라는 말은 너무 난해하다.

필승 전략이 있는 게임은 결국 지겨워진다. 그것처럼 좋은 구조로의 꾸준한 발전을 오히려 즐기는 것도 신나는 일일것이다.

<br/>

# 단순함

코드를 단순하게 유지하면 전체 코드를 줄일 수 있다. 이러면 코드를 고칠 때 먼저 머리에 담아야 할 양이 줄어든다.

코드가 단순하다고 짜는 시간이 적은 건 아니다. 좋은 해결책은 코드를 덧 붙이는 게 아니라 필요없는 코드를 최대한 뺴는 것이다.

하지만, 대부분은 수많은 조건들의 향연이다. 즉, 수많은 상황을 지원해야 한다.

가장 쉬운 방법은 하나하나 전부 코드로 옮기면 된다. 생각나는 대로 조건을 열거하는 것인데 초보 개발자가 흔히 이렇게 한다.

이런 코드는 우아하지도 않고 조금 다른 경우가 생기면 동작하지 않는다. 우아한 해결책이란, **적은 로직으로도 많은 경우의 수를 정확하게 처리할 수 있는 코드**를 뜻한다.

<br/>

# 마치며

* 추상화와 디커플링을 잘 활용하면 코드를 점차 쉽고 빠르게 만들 수 있다. 하지만, 지금 고민 중인 코드에 유연함이 필요하다는 확신이 없으면 추상화와 디커플링을 적용하느라 시간을 낭비하지 말자
* 개발 내내 성능을 고민하고 최적화에 맞게 설계해야 한다. 하지만 가정을 코드에 박아넣어야 하는 저수준의 핵심 최적화는 가능하면 늦게 하자
* 게임 기획 내용을 확인해볼 수 있도록 빠르게 개발하되, 너무 서두르느라 엉망으로 만들진 말자. 결국 그 코드로 작업해야 하는 건 우리다
* 나중에 버릴 코드를 잘 만들겠다고 시간 낭비 하지 말자
* 무엇보다, **만드는 데서 재미를 느끼자**
