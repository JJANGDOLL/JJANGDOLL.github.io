---
title: "이벤트 큐"

categories:
  - GPP


tags:
  - gameprogrammingpattern
  - oop
  - eventqueue

toc: true
toc_label: Event Queue
toc_sticky: true

sidebar_main: true
---

메시지나 이벤트를 보내는 시점과 처리하는 시점을 디커플링한다.

<br/>

# Motivation

## GUI 이벤트 루프

UI 프로그래밍을 한 번이라도 해봣다면 이벤트를 들어봤을 것이다. 버튼을 클릭하거나 메뉴를 선택하거나 키보드를 눌러서 상호작용 할 때 마다 OS는 이벤트를 만들어 프로그램으로 전달한다. 프로그램에서는 이를 받아서 원하는 행위를 처리하도록 이벤트 핸들러 코드를 전달해야 한다.

이벤트를 받기 위해선 코드 어딘가에 이벤트 루프가 있어야 한다. 대강 이렇게 생겼다.

```cpp
while (running)
{
  Event event = getNextEvent();
  // Handle event...
}
```

getNextEvent 는 아직 처리하지 않은 사용자 입력을 가져온다. 이를 이벤트 핸들러로 보내면 마법처럼 어플리케이션이 살아 움직인다. 여기서 재밌는 점은 자기가 원할 때 이벤트를 가져온다는 사실이다. 유저가 눌렀다고 해서 OS가 코드를 바로 호출시키는 것은 아니다.

이벤트를 원할 때 가져올 수 있다는 얘기는 OS가 디바이스 드라이버로부터 입력 값을 받은 뒤 어플리케이션에서 getNextEvent 로 가져갈 때 까지 그 값을 어디엔가 저장해 둔다는 뜻이다. 그 어딘가가 큐 이다.

![q_1](/assets/images/gameprogrammingpattern/q_1.png)

<br/>

## 중앙 이벤트 버스

이벤트 주도 방식으로 구현된 게임은 거의 없지만, 게임에서 자체 이벤트 큐를 만들어 중앙 통신 시스템으로 활용하는 경우는 흔하다. 게임 시스템들이 디커플링 상태를 유지한 채로 서로 고수준 통신을 하고 싶을 때 사용한다.

특정 인-게임 이벤트가 발생할 때 풍선 도움말을 보여주는 튜토리얼 시스템을 만든다고 해보자. 예를 들어, 플레이어가 괴물을 처음으로 처치하면 "X를 눌러 전리품을 획득하세요"라는 말풍선을 보여주고 싶다고 하자.

게임 플레이 코드와 전투 코드는 이미 충분히 복잡할것이다. 거기다가 튜토리얼을 보여줄지를 검사하는 코드를  넣고싶지는 않다. 대신 중앙 이벤트 큐를 만들면 어느 정도 게임 시스템에서도 큐에 이벤트를 보낼 수 있다. 전투 코드라면 매번 적을 죽일 때 마다 '적이 죽었음' 이벤트를 보내는 식이다.

마찬가지로 모든 게임 시스템은 큐로부터 이벤트를 받을 수 있다. 튜토리얼 코드는 '적이 죽었음' 이벤트를 받으면 알려달라고 큐에 자신을 등록한다. 이러면 서로를 모르더라도 전투 시스템으로부터 튜토리얼 코드로 적이 죽었다는 사실을 전달할 수 있다.

![q_2](/assets/images/gameprogrammingpattern/q_2.png)

<br/>

## 진짜?

사운드 시스템을 예제로 들어보자. 사운드 시스템을 추가하기 위해 가장 간단한 방법부터 적용해본 뒤 어떻게 돌아가는 지를 살펴보자. 아이디와 볼륨을 받아 사운드를 출력하는 API를 제공하는 단순한 '오디오 엔진' 부터 만들어보자

```cpp
class Audio
{
public:
  static void playSound(SoundId id, int volume);
};
```

오디오 엔진은 적당한 사운드 리소스를 로딩하고 이를 출력할 수 있는 채널을 찾아서 틀어준다. 오디오 시스템이 어딘가에 구현되어 있다고 가정하고 메소드 구현은 아래와 같다.

```cpp
void Audio::playSound(SoundId id, int volume)
{
  ResourceId resource = loadSound(id);
  int channel = findOpenChannel();
  if (channel == -1) return;
  startSound(resource, channel, volume);
}
```

이후 UI에서 호출하고 싶다면 이렇게 하면 된다.

```cpp
class Menu
{
public:
  void onSelect(int index)
  {
    Audio::playSound(SOUND_BLOOP, VOL_MAX);
    // Other stuff...
  }
};
```

이 상태에서 메뉴를 옮겨다니다 보면 화면이 몇 프레임정도 멈출 때가 생긴다. 뭐가 문제일까?

<br/>

### 문제1. 오디오 엔진이 요청을 완전히 처리할 떄 까지 호출자를 블록한다

playSound 는 동기적이다. 스피커에 소리가 나기 전 까진 API가 블록된다. 사운드 파일을 로딩한다면 더 오래 기다려야된다. 그 동안 게임은 멈춘다.

문제는 이 뿐만 아니다. 몬스터가 플레이어에게 피해를 입어 소리를 지르게끔 해보자. 두 마리 몬스터를 한 프레임에 같이 맞출 수 있다. 그러면 소리를 동시에 질러야 한다. 만약 사운드에 대해 안다면 여러 소리가 섞일 때 파형이 더해진다는 사실을 알 것이다. 같은 소리 파형 두개가 동시에 출력되면 소리를 두 배 크기로 트는 것과 같아서 거슬려진다.

부하들이 우르르 나오는 보스전에도 비슷한 문제가 있다. 하드웨어적으로 동시에 출력할 수 있는 소리는 한계가 있다. 그 이상이 되면 출력이 무시되거나 끊긴다.

이런 문제를 해결하려면 전체 사운드 호출을 취합하고 우선순위에 따라 나열해야 한다. 하지만 우리의 오디오 API는 playSound를 하나씩 처리하기 때문에 사운드 요청을 한 번에 하나 밖에 볼 수 없다.


 <br/>

### 문제2. 요청을 모아서 처리할 수 없다

지금가진, 여러 다른 게임 시스템에서 playSound 를 마음대로 호출했다. 하지만, 최신 멀티코어 하드웨어를 최대한으로 활용하려면 각 기능들을 별도의 스레드로 나눠야 한다.

playSoundA API가 동기식이여서 코드는 호출한 쪽 스레드에서 실행된다. 여러 다른 게임 시스템에서 playSound 를 호출하면 여러 스레드에서 동시에 실행된다. playSound 예제 코드에 동기화 처리 로직도 없다.

오디오용 스레드를 별도로 만들면 문제가 더 심해진다. 오디오용 스레드는 다른 스레드가 바쁘게 서로를 침범하고 깨먹는 동안 멍하니 가만히 있는다.

<br/>

### 문제3. 요청이 원치 않는 스레드에서 처리된다

이 모든 문제의 원인은 오디오 엔진이 playSound 호출을 '하던 일을 멈추고 당장 사운드를 틀어' 라고 해석하는 즉시성이 문제다. 다른 게임 시스템은 자기가 편할 때 playSound 를 호출하지만 오디오 엔진 입장에서는 playSound 를 호출받으면 호출을 해야만 한다. 이를 해결하기 위해 요청을 받는 부분와 처리하는 부분을 나누려고 한다.

<br/>

# 패턴

큐는 요청이나 알림을 들어온 순서대로 저장한다. 알림을 보내는 곳에서는 요청을 넣은 뒤에 결과를 기다리지 않고 리턴한다. 요청을 처리하는 곳은 큐에 들어있는 요청을 나중에 처리한다. 요청은 직접 처리될 수도 있고, 다른 여러 곳으로 보내질 수도 있다. 이를 통해 요청을 보내는 쪽과 받는 쪽의 코드 뿐만 아니라 시간 측면에서도 디커플링 한다.

<br/>

# 언제 쓸 것인가?

메시지를 보내느 곳과 받는 곳을 분리하고 싶을 뿐이라면 관찰자 패턴이나 명령 패턴 같은 것으로 덜 복잡하게 처리할 수 있다. 메시지를 보내는 시점과 받는 시점을 분리하고 싶을 때만 큐가 필요하다.

pushing 과 pulling 의 시점에서 생각해보자. A코드는 B 코드에 일을 요청한다. 이 때 A 입장에서는 B 에게 요청을 밀어 넣는 것이 자연스럽다.

반대로 B 입장에서는 자기가 편할 때 요청을 가져와서 일하는 것이 편하다. 한쪽에서는 밀어넣고 한쪽에서는 가져온다면 이들 사이에 버퍼가 필요하다. 이게 바로 다른 디커플링 패턴은 제공하지 못하고 큐만 제공할 수 있는 기능이다.

큐는 요청받는 쪽에 제어권을 제공한다. 받는 쪽은 처리를 지연할수도, 모아서 처리할수도, 버릴 수도 있다. 요청을 보내는 곳으로부터 제어권을 빼앗아왔기에 가능하다. 보내는 쪾에서는 그저 요청을 큐에 넣은 후 잘 처리해주길 바라는 수 밖에 없다. 만약, 보내는 쪽에서 응답을 받아야 한다면 큐를 쓰기에 적합하지 않다.

<br/>

# 주의사항

이벤트 큐는 복잡하고 게임 구조에 전반적으로 영향을 미치는 경향이 있다. 그렇기 때문에 이벤트 큐 패턴을 어떻게 사용할지, 혹은 정말 사용할 지 신중하게 생각해야 한다.

<br/>

## 중앙 이벤트 큐는 전역 변수와 같다

이벤트 큐는 모든 게임 시스템에서 서로 메시지를 주고받는 복잡한 중앙 통로같은 역할로 많이 사용된다. 강력한 기반 시스템이지만 강력하다는 것이 항상 좋은 것은 아니다.

우리 대부분은 오랜 경험 끝에 전역 변수가 나쁘다는 것을 알게 되었다. 어떤 상태가 프로그램 어디에서나 접근 가능하면 미묘한 상호의존성 문제가 생기기 바련이다. 이벤트 큐 패턴에서는 중앙 이벤트 큐를 간단한 프로토콜로 깔끔하게 래핑하지만, 그래도 전역이니 여전히 이런 문제가 존재한다.

<br/>

## 월드 상태는 언제든 바뀔 수 있다

이벤트를 받았을 때에는 현재 월드 상태가 이벤트가 만들어진 당시의 상태와는 다를 수 있다는 점을 주의해야 한다. 그렇기 때문에 동기적으로 처리되는 이벤트보다 큐에 들어가는 이벤트에는 데이터가 훨씬 많이 필요하다. 동기 이벤트에서 '뭔가 발생했다'는 알림을 받는 쪽에서 바로 상황을 확인할 수 있다. 큐를 사용하게 되면 이런 일시적인 정보를 이벤트와 함께 담아야 나중에 쓸 수 있다.

<br/>

## 피드백 루프에 빠질 수 있다

모든 이벤트, 메시지 시스템은 아래처럼 순환이 생기지 않도록 주의해야 한다.

1. A가 이벤트를 보낸다.
2. B가 이벤트를 받아 응답으로 다른 이벤트를 보낸다.
3. 이 이벤트가 우연찮게 A의 작업이라 A가 이벤트를 받는다. 그 응답으로 다른 이벤트를 보낸다.
4. 2번으로 간다

메시징 시스템이 동기적이면 스택 오버플로 크래시가 발생해서 순환을 금방 찾을 수 있지만 시스템 큐일때가 문제다. 비동기이다 보니 콜스택이 풀려서 A와 B가 쓸데없이 이벤트를 주고받아도 게임은 계속 진행된다. 이런 문제를 회피하는 일반적인 규칙은 이벤트를 처리하는 코드 내에서는 이벤트를 보내지 않는 것이다.

<br/>

# 예제 코드

앞에서 본 Audio::playSound() 는 완벽하진 않지만 저수준 오디오 시스템을 호출하는 기본 기능을 제공한다. 이제 문제만 해결하면 된다.

첫 번쨰 문제는 API가 블록된다는 점이다. 사운드 함수를 실행하면 playSound 에서 실제 리소스를 로드해 실제 스피커에 소리가 나오기 전까진 아무것도 못하고 기다려야만 한다.

playSound가 바로 리턴하게 만드려면 사운드 출력 작업을 지연시킬 수 있어야 한다. 요청을 보류한 뒤 나중에 출력에 필요한 정보를 저장할 수 있도록 간단한 구조체부터 정의한다.

```cpp
struct PlayMessage
{
  SoundId id;
  int volume;
};
```

Audio 클래스가 보류된 사운드 관련 메시지를 저장해둘 수 있도록 저장 공간을 만들자. 기본 배열을 사용하며 기본 배열의 장점은 아래와 같다.

* 동적 할당이 필요 없다
* 메모리에 추가 정보나 포인터를 저장하지 않아도 된다
* 메모리가 이어져 있어 캐시하기 좋다

```cpp
class Audio
{
public:
  static void init()
  {
    numPending_ = 0;
  }

  // Other stuff...
private:
  static const int MAX_PENDING = 16;

  static PlayMessage pending_[MAX_PENDING];
  static int numPending_;
};
```

배열 크기는 최악의 경우에 알맞게 조정하면 된다. 소리를 내기 위해선 배열 맨 뒤에 메시지를 넣으면 된다.

```cpp
void Audio::playSound(SoundId id, int volume)
{
  assert(numPending_ < MAX_PENDING);

  pending_[numPending_].id = id;
  pending_[numPending_].volume = volume;
  numPending_++;
}
```

이러면 playSound를 바로 리턴시킬 수 있다. 아직 사운드를 내는 곳이 없다. 사운드 출력은 update 메소드로 옮긴다.

```cpp
class Audio
{
public:
  static void update()
  {
    for (int i = 0; i < numPending_; i++)
    {
      ResourceId resource = loadSound(pending_[i].id);
      int channel = findOpenChannel();
      if (channel == -1) return;
      startSound(resource, channel, pending_[i].volume);
    }

    numPending_ = 0;
  }

  // Other stuff...
};
```

이제 적당한 위치에서 update 를 호출하면 된다. '적당한 곳'은 상황마다 다르다.

이렇게 한다면 동작은 하지만 update 한번에 모든 사운드 요청을 다 처리할 수 있다. 사운드 리소스가 로드된 다음에 비동기적으로 요청을 처리해야 한다면 이렇게 하면 안된다. 즉, update 한번에 하나의 요청만 처리할 수 있는 진짜 큐가 필요하다.

<br/>

## 원형 버퍼

우선 용어부터 정리한다.

* 머리는 큐에서 요청을 읽을 위치이다. 가장 먼저 보류된 요청이다.
* 꼬리는 반대다. 새로운 요청이 들어갈 자리이다.

playSOund는 배열 맨 뒤에 요청을 추가한다.

```cpp
class Audio
{
public:
  static void init()
  {
    head_ = 0;
    tail_ = 0;
  }

  // Methods...
private:
  static int head_;
  static int tail_;

  // Array...
};

void Audio::playSound(SoundId id, int volume)
{
  assert((tail_ + 1) % MAX_PENDING != head_);

  // Add to the end of the list.
  pending_[tail_].id = id;
  pending_[tail_].volume = volume;
  tail_ = (tail_ + 1) % MAX_PENDING;
}

void Audio::update()
{
  // If there are no pending requests, do nothing.
  if (head_ == tail_) return;

  ResourceId resource = loadSound(pending_[head_].id);
  int channel = findOpenChannel();
  if (channel == -1) return;
  startSound(resource, channel, pending_[head_].volume);

  head_ = (head_ + 1) % MAX_PENDING;
}
```

머리가 가르키는 요청을 처리한 후에는 머리 포인터를 오른쪽으로 옮겨 요청 값을 버린다. 머리와 꼬리가 겹쳤는 지를 보고 큐가 비었는 지를 확인할 수 있다.

<br/>

## 요청 취합하기

같은 소리를 동시에 틀면 소리가 너무 커지는 현상이 있었다. 이제는 대기중인 요청을 확인할 수 있기에 같은 요청이 있다면 병합해버리면 된다.

```cpp
void Audio::playSound(SoundId id, int volume)
{
  // Walk the pending requests.
  for (int i = head_; i != tail_;
       i = (i + 1) % MAX_PENDING)
  {
    if (pending_[i].id == id)
    {
      // Use the larger of the two volumes.
      pending_[i].volume = max(volume, pending_[i].volume);

      // Don't need to enqueue.
      return;
    }
  }

  // Previous code...
}
```

같은 소리를 출력하는 요청이 먼저 들어와 있다면 둘 중 소리가 큰 값으로 합쳐진다.

요청을 처리할 때가 아닌 큐에 넣기 전에 취합이 먼저 일어난다는 점에 주의하자.

호출하는 쪽의 처리 부담이 늘어난다는 단점이 있다. playSound 는 큐를 쭉 돈 뒤에 리턴하기에 큐가 크면 느릴 수 있다. 그럴 때는 update 에서, 즉 요청을 처리할 때 취합하는 편이 나을 수도 있다.

이벤트 큐 패턴은 요청자가 실제 요청이 언제 일어나는 지 모르게 막는다. 하지만 큐가 이런 식으로 상황에 따라 다르게 동작한다면, 큐에 넣은 요청이 실제로 처리될 때 까지 시간이 동작에 영향을 미칠 수 있다. 먼저 점검한 후 사용하자.

<br/>

## 멀티스레드

가장 골치아픈 문제이다. 동기식으로 만든 오디오 API는 playSound 를 호출한 스레드에서 요청도 같이 처리해야 했다. 바람직하진 못하다.

요즘 같은 멀티코어 하드웨어에서는 멀티 스레드를 활용해 성능을 최대한으로 끌어내야 한다. 스레드에서 코드를 본해하는 방법은 다양하지만, 시슽메별로 할당하는 전략을 많이  쓴다.

1. 사운드 요청 코드와 사운드 재생 코드가 분리되어 있다.
2. 양쪽 코드 사이에 마샬링을 제공하기 위한 큐가 있다.
3. 큐는 나머지 코드로부터 캡슐화 되어 있다.

이제 큐를 변경하는 코드인 playSOund와 update 를 스레드로부터 안전하게 만들면 된다.

고수준에서만 언급하자면 큐가 동시에 수정되는 상황만 막으면 된다. playSOund 는 몇몇 필드에 값만 할당할 뿐 작업이 많이 없기 때문에 블록해도 오래걸리지 않는다. update 에서는 조건 변수 같은 것으로 기다리게 만들면 처리할 요청이 없는 동안 CPU 낭비를 막을 수 있다.

<br/>

# 디자인 결정

## 큐에 무엇을 넣을 것인가?

'이벤트'와 '메시지'를 혼합해서 섞어 왓지만, 둘은 개념적으로 약간 다르다.

<br/>

### 큐에 이벤트를 넣는 경우

'이벤트' 혹은 '통지'는 '몬스터가 이미 죽었음' 같은 이미 발생한 사건을 표현한다. 이벤트를 큐에 넣으면, 다른 객체가 비동기 관찰자 패턴 같은 방식으로 이벤트에 반응할 수 있다.

* 복수개의 리스너를 지원해야 할 때도 많다
* 큐의 범위가 넓은 편이다

<br/>

### 큐에 메시지를 넣는 경우

'메시지' 또는 '요청'은 '사운드 틀기' 같은 나중에 실행 했으면 하는 행동을 표현한다. 서비스에 비동기적으로 API를 호출하는 것과 비슷하다고 보면 된다.

* 대부분 리스너가 하나다

<br/>

## 누가 큐를 읽는가?

예제에서는 큐가 캡슐화 되어 있어 Audio 클래스에서만 읽을 수 있었다. UI의 이벤트 시스템 같은 곳에서는 원하는 대로 리스너를 등록할 수 있다. 이들을 구별하기 위해 '싱글캐스트'나 '브로드캐스트' 같은 용어를 쓰며, 두 방식 모두 쓸모가 있다.

<br/>

### 싱글캐스트 큐

큐가 어떤 클래스의 API일 때 적합하다.

* 큐는 밖에서 보이지 않는 내부 구현이 된다
* 큐가 더 캡슐화 되어있다
* 리스너 간에 경쟁을 고민하지 않아도 된다

 <br/>

 ### 브로드캐스트 큐

 대부분의 '이벤트' 시스템이 이런 식이다. 리스너가 10개 있다면 이벤트가 하나 들어왔을 때 10개의 리스너가 모두 볼 수 있다.

 * 이벤트가 무시될 수 있다
 * 이벤트 필터링이 필요할 수 있다.

 <br/>

 ### 작업 큐(work queue)

 작업 큐에도 리스너가 여러 개 있다. 차이점은 큐에 들어있는 데이터가 리스너 중 한곳에만 간다. 스레드 여러 개가 동시에 실행중인 스레드풀 작업에 나눠줘야 할 때 일반적으로 사용하는 패턴이다.

 * 작업을 분배해야 한다.

 <br/>

 ## 누가 큐에 값을 넣는가?

 ### 넣는 측이 하나라면

 동기형 관찰자 패턴에 가까운 형태이다. 하나의 특정 객체에서만 이벤트를 만들고 나머지는 이벤트를 받는 것만 가능하다.

 * 어디에서 이벤트가 오는지 암시적으로 안다
 * 보통 리스너가 여러개다

 <br/>

 ### 넣는 측이 여러개라면

 * 이벤트 순환을 조심해야 한다
 * 이벤트를 보낸 객체에 대한 레퍼런스를 이벤트에 추가해야 할 필요가 있을 수 있다

 <br/>

 ## 큐에 들어간 객체의 생명 주기는 어떻게 관리할 것인가?

 동기형 알림에서는 받는 쪽에서 메시지 처리가 끝나기 전에는 리턴하지 않기에 보내는 쪽에서 기다려야만 한다. 즉, 메시지는 스택에 들어가는 지역변수이기만 해도 충분하다. 큐에서는 큐에다 메시지를 추가하는 함수 호출이 끝난 후에도 메시지 객체가 유지되어야 한다.

GC를 지원하는 언어에서는 이런 문제를 크게 고민하지 않아도 된다.

<br/>

### 소유권을 전달한다

메모리를 직접 관리하는 언어에서 가장 전통적으로 사용하는 방식이다. 메시지가 큐에 들어가고 나면, 메시지의 소유권을 큐가 가져가고 보내는 쪽에서는 더이상 소유하지  않는다. 데이터를 처리할 때는 받는 쪽에서 메시지 소유권을 가져가고 메시지 해제도 해야한다.

<br/>

### 소유권을 공유한다.

소유권을 공유하는 방식에서는 메시지를 참조하는 곳이 어디 하나라도 있다면 계속 메모리에 남아있다가 어디서도 참조하지 않으면 알아서 해제된다.

<br/>

### 큐가 소유권을 가진다

메시지 큐가 메시지의 생명을 관리하는 방법도 있다. 보내는 쪽에서는 메시지를 직접 생성하지 않고 큐에 새로운 메시지를 하나 달라고 욫어한다. 큐는 미리 할당해놓은 메시지의 레퍼런스를 반환하고 보내는 쪽에서는 여기에 값을 채운다. 처리가 끝나면 받는 쪽에서 이 메시지를 참조한다.


