---
title: "게임 루프"

categories:
  - GPP


tags:
  - gameprogrammingpattern
  - oop
  - gameloop

toc: true
toc_label: Game Loop
toc_sticky: true

sidebar_main: true
---

게임 시간 진행을 유저입력, 프로세서 속도와 디커플링 합니다.

<br/>

# Motivation

과거의 프로그래머는 모든 코드를 들이부은 뒤에 버튼을 누르고 한참 기다리면 결과를 볼 수 있었다. 이런 걸 배치모드 프로그램이라고 하는데 작업이 끝나면 프로그램은 멈췄다. 짧은 파이썬 스크립트도 배치 모드 프로그램에 속한다.

<br/>

## CPU와의 인터뷰

즉각적인 피드백을 원하던 프로그래머들은 대화형(interactive) 프로그램을 만들었고 실시간으로 대화를 나눌 수 있게 되었다. 프로그램은 입력을 기다렸다가 내 말에 대답한다. 코드로 표현하면 아래와 같다.

```cpp
while (true)
{
  char* command = readCommand();
  handleCommand(command):
}
```

<br/>

## 이벤트 루프

최신 GUI 프로그램도 내부를 들여다보면 비슷하다. 

```cpp
while (true)
{
  Event* event = waitForEvent();
  dispatchEvent(event);
}
```
 
GUI 프로그램 역시 문자 입력 대신 마우스나 키보드 입력 이벤트를 기다리다는 것 외엔 사용자 입력을 받을 떄 까지 멈춰있는 옛날 동작 방식에서 별 바뀐게 없다.

하지만, 게임은 유저 입력 없어도 계속 돌아가야 한다. 유저 입력이 없어도 애니메이션, 시각적 연출은 계속 되어야 한다.

루프에서 사용자 입력을 처리하지만 마냥 기다리고만 있지 않는다. 이것이 게임 루프의 첫번째 핵심이다. 루프는 계속 돌아가야만 한다.

```cpp
while (true)
{
  processInput();
  update();
  render();
}
```

기본 코드는 크게 변경되지 않았다. processInput 에서는 이전 호출 이후로 들어온 유저 입력을 처리한다. update 에선 게임 시뮬레이션을 AI와 물리 (보통 이 순서대로) 처리한다. render 에선 플레이어가 어떤 일을 벌어지는 지 알 수 있도록 화면을 렌더한다.

<br/>

## 게임 월드에서 시간

루프가 입력을 기다리지 않는다면 루프가 도는데 시간이 얼마나 걸리는 지가 궁금하다. 게임 루프가 돌 때 마다 게임 상태는 조금씩 진행된다. 게임 월드 주민 입장에서는 게임 시간이 계속 흘러가고 있다.

그동안 플레이어의 실제 시간도 흘러간다. 게임 루프가 얼마나 많이 돌았는지를 측정하면 초당 프레임 수(FPS)를 얻을 수 있다. 게임 루프가 빠르게 돌면 FPS가 부드럽고 빠른 화면을 볼 수 있다. 그 반대의 경우는 스톱모션 영화처럼 뚝뚝 끊어져 보인다.

앞에서 대충 만든 코드는 무저껀 빠르게 루프를 돌기 때문에, 두 가지 요인이 프레임 레이트를 결정한다. 하나는 한 프레임에 얼마나 많은 작업을 하는가? 이다. 물리 계산이 복잡하고 게임 객체가 많으며 그래픽이 정교해 CPU,GPU가 바쁘다면 한 프레임에 걸리는 시간이 늘어난다.

다른 요인은 코드가 실행되는 플랫폼의 속도이다. 하드웨어 속도가 빠르다면 같은 시간에 더 많은 코드를 실행할 것이다. 멀티코어, GPU, 전용 오디오 하드웨어, OS 스케쥴러 등도 실행 시간에 영향을 미친다.

<br/>

## 게임 시간 vs 실제 시간

게임 개발 초창기엔 두 번째 요인이 정해져있었다. 패미컴이나 애플 II용 게임은 어느 CPU에서 실행될 지 미리 알 수 있었기 때문에, 특정 CPU 전용 코드를 사용할 수 있었고 실제로도 그렇게 했다. 개발자는 한 틱에 얼마나 많은 작업을 할 지만 정하면 됬었다.

이 당시에는 게임이 원하는 속도를 낼 수 있도록 매 프레임마다 작업을 얼마나 할지를 고민해야했다. 같은 게임을 더  빠른, 더 느린 기계에서 실행하면 게임 속도도 같이 빨라지거나 느려졌다.

요즘 개발 중인 게임은 정확히 어느 하드웨어에서 실행될 지 알수 있는 행복한 경우가 거의 없다. 대신 여러 기기에서 잘 돌아갈 수 있도록 만들어야 한다.

이처럼, 어느 기기에서라도 일정한 속도로 돌아갈 수 있도록 하는 것이 게임 루프의 또 다른 목표이다.

<br/>

# 패턴

게임 루프는 게임이 실행되는 내내 돌아간다. 한 번 돌 때마다 멈춤없이 유저입력, 게임 상태 업데이트, 게임 화면 렌더링 같은 작업을 진행한다. 시간 흐름에 따라 게임 플레이 속도를 조절한다.

<br/>

# 언제 쓸 것인가?

게임 루프 패턴은 게임 안에서 무저껀 사용 될 것이라고 자신할 수 있다. 턴제 게임이라고 루프가 필요없다고 생각할 수 있지만 시각 및 청각 상태는 계속 바껴야 한다. 우리는 유저의 턴이 끝날 떄 까지 '기다리는' 동안에도 애니메이션과 음악은 재생되야 한다.

<br/>

# 주의사항

게임 루프는 게임 코드 중에서도 핵심 코드이다. 10%의 코드가 프로그램 실행 시간의 90%를 차지한다 해도 과언이 아니다. 그렇기 때문에 최적화를 고려해 깐깐하게 만들어야 한다.

<br/>

## 플랫폼의 이벤트 루프에 맞춰야 할 수도 있다

그래픽 UI와 이벤트 루프가 들어 있는 OS나 플랫폼에서 게임을 만드는 경우엔, 어플리케이션 루프가 두 개 있는 셈이므로 서로를 잘 맞춰야 한다.

제어권을 가져와 우리 르프만 남겨 놓을 수도 있다. 오래된 윈도우 API로 만든다면, main 에서 게임 루프를 두고 루프 안에서 PeekMessage 를 호출해 OS로부터 이벤트를 가져와 전달하는 식으로 만들 수 있다. GetMessage 와 달리 PeekMessage 는 유저 입력이 올 떄 까지 기다리지 않아서 게임 루프를 멈추지 않고 계속 돌아가게 할 수 있다.

플랫폼에 따라서는 내부 이벤트 루프를 무시하기 어려울 수도 있다. 웹 브라우저에서는 이벤트 루프가 브라우저 실행 모델 깊숙한 곳에서 모든 것을 좌지우지 하기 때문에 이걸 게임 루프로 사용해야만 한다. 게임이 돌아가게 하려면 requestAnimationFrame 같은 걸 호출한 뒤에 브라우저가 우리 코드를 콜백으로 호출해주기를 기다려야 한다.

<br/>

# 예제

설명이 길지만 사실 게임 루프 코드는 굉장히 짧다. 여러 구현 방법을 장단점과 함꼐 살펴보자.

게임 루프에서 AI와 렌더링 같은 게임 시스템을 진행하지만 패턴에만 집중하기 위해 가상의 함수를 호출한다. render, update 같은 함수는 있지만 구현하는 것은 여러분의 몫이다.

<br/>

## 최대한 빨리

가장 간단한 게임 루프 형태는 아래와 같다.

```cpp
while(true)
{
  processInput();
  update();
  render();
}
```

이 방식은 속도를 제어할 수 없다는 문제가 있다. 빠른 하드웨어에서는 빠르게 돌아가고 느린 하드웨어에서는 느리게 돌아간다. 연산량이 많은 월드로 가면 빠르다가도 느려질 수 있다.

<br/>

## 한 숨 돌리기

여기서는 위 문제를 간단하게 해결한다. 게임을 60FPS 로 돌린다면 한 프레임에 16ms(1/60 = 0.016...) 가 주어진다. 그 안에 게임 진행과 렌더링을 다 할수 있다면 60FPS를 유지할 수 있다. 작업을 실행한 뒤 기다리기만 하면 된다.

```cpp
while(true)
{
  double start = getCurrentTime();
  processInput();
  update();
  render();

  sleep(start + MS_PER_FRAME - getCurrentTime());
}
```

다행히 이젠 작업이 빨리 끝나도 너무 빨라지지 않는다. 다만, 너무 느려지는 건 못 막는다. 한 작업을 하는 데 16ms 이상 걸린다면 sleep 함수 시간이 음수가 되버린다. 

<br/>

## 한 번은 짧게, 한 번은 길게

좀 더 정교하게 만들어보자. 문제는 결국 다음 두가지로 볼 수 있다.

* 업데이트 할 때 마다 정해진 만큼 게임 시간이 진행된다
* 업데이트하는 데에는 현실 세계의 시간이 어느 정도 걸린다

60FPS를 기준으로 한 번 작업이 현실 시간으로 16ms 이상 걸리면 따라갈 수가 없다. 다만, 그 이하로 걸리는 경우에는 적절히 실행할 수 있다.

즉, 프레임 이후 실제 시간이 얼마나 지났는지에 따라 시간 간격을 조정하면 된다. 프레임이 오래 걸릴수록 게임 간격을 길게 잡는다. 필요에 따라 업데이트 단계를 조절시킬 수 있으니 실제 시간을 따라갈 수 있다. 이런 것을 가변 시간 또는 유동 시간 간격이라고 한다.

```cpp
double lastTime = getCurrentTime();
while(true)
{
  double current = getCurretTime();
  double elapsed = current - lastTime;
  processInput();
  update(elapsed);
  render();
  lastTime = current;
}
```

매 프레임마다 이전 게임 업데이트 이후 실제 시간이 얼마나 지났는지를 elapsed 에 저장한 뒤 update 에 인자로 넘겨줍니다. update 에선 받은 시간을 기준으로 게임 월드 상태를 진행합니다.

게임에서 총알이 날아가는 상황이다. 고정 시간 간격에선 매 프레임마다 총알 속도에 맞춰 총알이 움직인다. 가변 시간 간격에선 속도와 지나간 시간을 곱해서 이동 거리를 계산한다.(시간 간격이 커지거나 작아지면 그 양에 맞춰 움직인다) 이제 업데이트를 20번하든 4번하든 상관없이 실제 시간 동안 같은 거리를 움직인다. 이제 해결된 것 처럼 보인다.

* 다양한 하드웨어에서 비슷한 속도로 게임이 돌아간다
* 더 빠른 하드웨어를 사용하는 유저는 더 부드러운 게임 플레이를 즐길 수 있다

하지만 심각한 문제가 숨어있다. 어떤 함정이 숨어있는지 보자.

2인용 네트워크 게임을 한다고 가정하자. 무지는 끝내주는 게임용 PC를 쓰지만 프로도는 오래된 문서 작성용 PC로 접속을 했다. 앞선 예로 총알이 날아다니기 시작하는데 무지 컴퓨터에서는 1초에 60번의 프레임이 돌아가지만, 프로도는 5번 밖에 업데이트를 못한다.

즉, 무지는 60 번의 게임 업데이트를 실행하는 반면 프로도는 5번 밖에 업데이트 못한다. 보통 게임에서는 부동 소수점을 사용하기 떄문에 반올림 오차가 생기기 쉽다. 부동 소수점을 더할 때 마다 결과 값에 오차가 생기기 마련이고 무지의 컴퓨터는 덧셈 계산을 12배 더 하기 때문에 오차가 더 크게 쌓이고 결국 PC에 따라 같은 총알의 위치가 달라진다.

가변 시간 간격에서 생기는 문제는 더 있다. 실시간으로 실행하기 위해 게임 물리 엔진은 실제 물리 법칙의 근사치를 취하는데 근사치가 튀는 것을 막기 위해 감쇠를 적용한다. 감쇠는 시간 간격에 맞춰 세심하게 조종해야 한다. 감쇠 값이 바뀌면 물리가 불안정해진다.

<br/>

## 따라잡기

가변 시간 간격에 영향을 받지 않는 부분 중 하나가 렌더링이다. 렌더링은 실행되는 순간을 포착할 뿐, 그 이후로 어느 시간이 지났는지 고려하지 않는다. 그냥 때가 되면 렌더링 한다.

이 점을 활용해보자. 더 간단하게 만들고, AI도 좀 더 안정적으로 만들기 위해 고정 시간 간격으로 업데이트 한다. 렌더링 간격은 유연하게 만들어 프로세서 낭비를 줄이자.

원리는 아래와 가다. 이전 작업 이후 실제 시간이 얼마나 지났는 지 확인 후, 게임의 현재 시간이 실제 시간의 현재를 따라 잡을 때 까지 고정 시간 간격만큼 게임 시간을 여러 번 시뮬레이션 한다.

```cpp
double previous = getCurrentTime();
double lag = 0.0;
while(true)
{
  double current = getCurretTime();
  double elapsed = current - previous;
  previous = current;
  lag += elapsed;
  processInput();

  while(lag >= MS_PER_UPDATE)
  {
    update(elapsed);
    lag -= MS_PER_UPDATE;
  }
  render();
}
```

프레임이 시작할 때 마다 실제 시간이 얼마나 지났는지 lag에 저장한다. 이 값은 실제 시간에 비해 게임 시간이 얼마나 뒤쳐졌는 지를 의미한다. 그 다음으로 안에서 고정 시간 간격 방식으로 루프를 돌면서 실제 시간을 따라 잡을 떄 까지 업데이트 한다. 다 따라잡은 이후엔 렌더링 하고 다시 루프를 실행한다.

여기서 MS_PER_UPDATE 가 더 이상 시각적 프레임 레이트가 아닌 것을 확인하자. 게임을 얼마나 촘촘하게 업데이트 할 지에 대한 값일 뿐이다. 시간 간격이 짧을 수록 실제 시간을 따라잡기가 더 오래걸리고, 시간 간격이 길수록 게임 플레이가 끊겨 보인다. 60FPS 보다 빠르게 돌아가도록 시간 간격을 충분히 짧게 잡아 좋은 PC 시뮬레이션에는 훨씬 그럴싸하게 보이도록 만드는게 이상적이다.

하지만 시간 간격이 너무 짧아지지 않도록 주의한다. 가장 느린 하드웨어 에서도 update 하는데 걸리는 시간 보다는 시간 간격이 커야한다. 그렇지 않으면 게임 시간은 계속 뒤쳐지게 된다.

다행히 렌더링을 update 에서 뺏기 때문에 CPU 시간에 여유가 생겼다. 느린 PC 에서는 화면이 조금 끊기겠지만, 결과적으로 안전한 고정 시간 간격을 이용해 여러 하드웨어에서 일정한 속도로 시뮬레이션 할 수 있다.

<br/>

## 렌더링이 중간에 끼는 경우

업데이트를 고정적으로 하더라도 렌더링은 업데이트 중간에 되는 경우가 종종 있다.

![gl_t](/assets/images/gameprogrammingpattern/gl_t.png)

업데이트는 고정 간격으로 진행하지만, 렌더링은 가능할 때 마다 한다. 세 번째 업데이트 같은 경우는 두 업데이트 사이에 일어난다.

두 업데이트 기준으로 총알이 화면을 지나가는데 왼쪽에 있다가 다음 업데이트 때는 오른쪽에 가 있어야 한다.  근데, 지금 구현에서는 렌더링하면 여전히 왼쪽으로 보인다. 즉, 움직임이 튀어보인다.

다행히 렌더링 할 때 업데이트 프레임이 시간적으로 얼마나 떨어져 있는 지를 lag 값을 보고 판단할 수 있다. lag 값이 0이 아니고 업데이트 시간 보다 적을 때에는  업데이트 루프를 빠져나온다. 이때 lag 에 있는 값이 다음 프레임 까지 남은 시간이다.

렌더링 할 때 다음처럼 인자를 넘긴다.

```cpp
render(lag / MS_PER_UPDATE);
```

렌더러는 게임 객체들과 각각의 현재 속도를 안다. 총알이 화면 왼쪽에서 20px 에 있고 오른쪽으로 프레임당 400px 을 움직인다고 하자. 프레임 중간이라면 render 는 0.5의 인수를 받아서 총알을 한 프레임의 중간인 220px 에 그린다. 그러면, 움직임이 부드러워 진다.

물론 이런 보간은 틀릴 수 있다. 다음 프레임에 벽에 부딪혔거나 느려졌을 수도 있다. 렌더링에서는 현재 프레임에서 다음 프레임 사이의 예상 위치를 보간한다. 하지만 물리와 AI를 실제 업데이트 하기 전엔 정확한 위치를 알 수 없다.

보간은 어느 정도 추측하기 때문에 틀릴 수 있다. 하지만 잘 눈에 듸지 않아서 보간을 하지 않는 것 보단 눈에 덜 거슬린다.

<br/>

# 디자인 결정

고수준으로 갈 수록 확인해봐야 할 질문들을 살펴보자.

<br/>

## 게임 루프를 직접 관리하는가, 플랫폼이 관리하는 가?

대부분은 선택의 여지가 없다. 웹 부라우저는 이벤트 기반이라 루프를 따로 만들지 못하게 막혀있고, 웹 브라우저용 게임에서는 전형적인 게임 루프를 직접 만들 가능성은 거의 없다. 마찬가지로 게임 엔진을 사용한다면 게임 루프를 직접 만들기 보단 엔진에 들어있는 게임 루프를 그대로 쓸 가능성이 높다.

<br/>

### 플랫폼 이벤트 루프 사용

* 간단하다
* 플랫폼에 잘 맞는다
* 시간을 제어할 수 없다

<br/>

### 게임 엔진 루프 사용

* 코드를 직접 작성하지 않아도 된다
* 코드를 직접 작성할 수 없다

<br/>

### 직접 마든 루프 사용

* 완전한 제어, 뭐든지 할 수 있다
* 플랫폼과 상호작용 해야된다

<br/>

## 전력 소모 문제

### 최대한 빨리 실행하기

PC 게임이 주로 이렇게 한다. 게임 루프에서 OS에 따로 sleep 을 사용하지 않는다. 대신 시간이 남으면 FPS나 그래픽 품질을 더 높인다.

이 방식은 최고의 게임 플레이를 제공하지만 전력도 많이 소모한다. 노트북으로 플레이 한다면 난로도 하나 얻는셈이다.

<br/>

### 프레임 레이트 제한

모바일에선 그래픽 품질보다는 게임 플레이 품질에 더 집중하는 편이다. FPS를 주로 30, 60 에 제한을 두고 남은 시간에 sleep 을 호출한다.

이러면 충분히 괜찮은 경험을 제공하지만 배터리 소모를 줄일 수 있다.

<br/>

## 게임플레이 속도는 어떻게 제어할 것인가?

게임 루프는 비동기 유저 입력과 시간 따라잡기라는 두 가지 핵심 요소가 있다. 입력은 쉽지만, 시간을 다루는게 어렵다. 게임을 실행하는 플랫폼은 넘쳐나기에 이런 다양한 플랫폼을 어떻게 지원하느냐가 핵심이다.

<br/>

### 동기화없는 고정 시간 간격 방식

게임 루프를 최대한 빠르게 실행한다.

* 간단하다
* 게임 속도는 하드웨어와 게임 복잡도에 직접적인 영향을 받는다

<br/>

### 동기화하는 고정 시간 간격 방식

좀 더 복잡한 방법이다. 고정 시간 간격으로 게임을 실행하지만, 루프 마지막에 지연이나 동기화를 넣어 너무 빨리 실행되는 것을 막는다.

* 그나마 간단하다
* 전력 효율이 높다
* 게임이 너무 빨라지진 않는다
* 게임이 너무 느려질 수는 있다

<br/>

### 가변 시간 간격 방식

* 너무 느리거나 너무 빠른 곳에서도 맞춰서 플레이 할 수 있다
* 게임플레이를 불안정하고 비결정적으로 만든다

<br/>

### 업데이트는 고정 시간 간격으로, 렌더링은 가변 시간 간격으로

* 너무 느리거나 너무 빨라도 잘 적응한다
* 훨씬 복잡하다

<br/>
