---
title: "어댑터 패턴"

categories:
  - DESIGNPATTERN


tags:
  - designpattern
  - oop
  - adapter

toc: true
toc_label: Adapter
toc_sticky: true

sidebar_main: true
---

인터페이스를 추상화해서 서로 다른 인터페이스를 통일합니다. 상속을 통한 어댑터와 합성을 통한 어댑터로 구분됩니다.

<br/>

# 잘못된 코드

세상 어디에도 완벽한 코드는 없습니다. 결국 사람이 만든 것이기에 어딘가에 실수가 있기 마련입니다.

## 오류 코드

개발 당시에는 발견되지 못했던 코드가 나중에 발견되기도 합니다. 또는 당시에는 정상적이었던 동작이 환경의 변화로 인해 문제가 되는 경우도 많습니다. 

문제가 있는 코드를 재사용 하는 소프트웨어는 문제를 내포하게 됩니다. 그렇기에 오류를 찾으면 찾아서 수정해야 합니다.

오류는 언제나 존재합니다. 소프트웨어는 개발 과정도 중요하지만 안정적인 코드 동작과 유지보수도 매우 중요합니다.

<br/>

## 수정 불가

재사용된 코드 중 일부는 수정을 할 수 없는 것도 많습니다. C, java 같이 컴파일이 가능한 언어는 원본 소스 코드를 분실해서 컴파일된 목적 파일만 남은 경우도 있습니다. 특히, 잘 알지 못하는 개발자의 이전 코드를 재사용하고자 할 때 자주 발생하며 코드 변경을 요청할 수도 없습니다.

이런 상황이라면 유지보수를 요청할 수가 없고 직접 해결해야됩니다. 이때는 오류가 포함된 코드를 감싸서 보정 코드를 만들어 사용합니다. 즉, 보정 코드를 통해 문제점을 우회합니다.

<br/>

## 보정 코드

보정 코드는 발생한 오류를 수정하고 기능을 변경합니다. 보정 코드를 만드는 방법은 다양합니다. 보정 코드는 조건을 다르게 처리해서 코드를 호출합니다.

보정 동작이 여러 곳에 분포한다면 많은 영역의 코드가 수정되야 합니다. 소스에서 보정된 영역이 많으면 가독성이 떨어집니다. 이런 경우 별도 객체를 생성해서 보정을 처리하는 것이 좋습니다.

<br/>

# 어댑터 패턴

어댑터 패턴은 코드를 재사용하기 위한 인터페이스를 처리하고 인터페이스를 활용해 보정 코드를 작성합니다.

<br/>

## 코드 래퍼 처리

어댑터 패턴은 다른 말로 래퍼 패턴(wrapper pattern)이라고 합니다. 기존의 클래스를 새로운 클래스로 감싸는 기법입니다. 래퍼 처리로 기존의 기능은 유지하면서 변경된 추가 코드를 삽입합니다. 래퍼 처리된 객체를 어댑터라고 합니다.

![Adapterconn](/assets/images/designpattern/adapterconn.png)

* Adapter : 변환을 처리하는 객체
* Adaptee : 변환을 받아 사용하는 객체

<br/>

## 호환성

문제점을 가친 객체를 래퍼하면 새로운 객체가 됩니다. 기존 객체를 감싼 또 다른 객체입니다. 새로 생성되는 객체는 `클라이언트-어댑터` 간 호환을 위해 인터페이스를 갖고 있습니다.

하지만 어댑티가 기존 객체(client)의 인터페이스와 호환이 되지 않을 수 있는데, 이때는 새로운 환경에 맞게 어댑터를 재설계해야 합니다.

어댑터는 어댑티가 클라이언트와 통신할 수 있도록 인터페이스의 구조를 변경하는 패턴입니다.

<br/>

## 중개 행동 패턴

어댑티는 기존의 코드와 새로운 클라이언트 간의 역할을 중개합니다. 어댑티가 원활한 중개를 하기 위해 인터페이스를 재설계합니다.

어댑터 패턴은 2개의 클래스를 중개한다고 해서 중개 패턴으로도 불립니다. 어댑터는 중개적인 특징을 이용해 코드의 재사용을 높입니다. 중개는 새로운 기능을 제공하는 것이 아닌 전달 역할만을 목적으로 합니다.

<br/>

## 어댑터 종류

어댑터는 다른 객체의 구조를 내가 원하는 인터페이스 방식으로 개선합니다.

구조를 개선하는 방법은 상속을 이용한 방법과 구성을 이용한 방법으로 나누어집니다.

* 클래스 어댑터 : 상속
* 객체 어댑터 : 구성

<br/>

## 설계

### 기존 코드

곱셈을 계산하는 클래스입니다.

```cpp
class Math
{
public:
    float TwoTime(float num)
    {
        return num * 2;
    }

    float HalfTime(float num)
    {
        return num / 2;
    }
};
```

근데 인자로 실수가 아닌 정수를 받도록 변경해봅시다. 자료형이 변했기 때문에 이 클래스를 더이상 사용할 수 없습니다. 어댑터 패턴을 이용해서 문제를 해결해봅시다.

어댑터 패턴을 설계하기 위해 먼저 최종 객체가 가져야 할 인터페이스를 정의합니다. 클라이언트는 새로운 구현 방식이 아닌 인터페이스 변경으로 문제를 해결합니다.

인터페이스의 비호환성으로 인해 코드를 재사용할 수 없을 때는 인터페이스를 맞추기 위해 코드를 상속하는 클래스를 맞추거나 새로운 인터페이스를 가진 클래스를 만들어 해결합니다.

<br/>

### 어댑터 제작

인터페이스 문제를 해결하기 위해 어댑터 패턴을 적용합니다.

```cpp
class Adapter
{
public:
    virtual int TwoTime(int num) = 0;
    virtual int HalfTime(int num) = 0;
};

class Objects: public Adapter
{
private:
    Math* math;

public:
    Objects()
    {
        math = new Math();
    }

    ~Objects()
    {
        delete math;
    }

    virtual int TwoTime(int num) override
    {
        return (int)math->TwoTime((float)num);
    }

    virtual int HalfTime(int num) override
    {
        return (int)math->HalfTime((float)num);
    }
};
```

새로운 Object 객체는 Math 클래스를 상속받지 않습니다. 대신 생성자에서 Math 객체를 생성합니다. 어댑터는 생성자에서 새로운 객체를 생성, 포함하기 때문에 복합객체입니다.

어댑터를 설계할 때는 새로운 인터페이스도 같이 적용합니다.