---
title: "그 밖의 이야기들"

categories:
  - EFCPP


tags:
  - oop
  - effective cpp

toc: true
toc_label: EFCPP_Part9
toc_sticky: true

sidebar_main: true
---

# 컴파일러 경고를 지나치지 말자

> 컴파일러 경고를 쉽게 지나치지 맙시다. 가능하다면 최고 경고 수준에도 경고 메시지를 내지 않는 코드를 짜도록 노력합시다.

> 컴파일러 경고에 너무 기대진 마십시오. 컴파일러마다 트집 잡고 경고를 내는 부분은 천차만별입니다. 지금 코드를 다른 컴파일러로 이식하면 익숙해져 있는 경고 메시지가 사라질 수 있스빈다.

누구나 한번 쯤 저지를 법한 실수가 있는 코드입니다.

```cpp
class B
{
public:
    virtual void f() const;
};

class D: public B
{
public:
    virtual void f();
};
```

이러면 이런 에러가 나오게 됩니다.

```
Warning: D::f() hides virtual B::f()
```

이 컴파일러는  지금 f가 D에서 재선언 된 것이 아닌 아예 가려져서 고함을 치고 있습니다.

경험을 많이 쌓이고 나면 컴파일러의 어떤 경고를 넘어가도 되고, 어떤 경고는 없애 주어야 하는지 선택할 수 있는 공력이 쌓입니다. 물론, 최고 경고 수준을 걸더라도 경고 메시지 없이 컴파일 되는 코드를 작성하는 것이 일반적으로 더 좋은 실천법이긴 합니다. 핵심은, 그 경고가 여러분에게 전하려는 메시지를 정확히 이해해야 한다는 것입니다.


<br/>

# 표준 라이브러리 구성 요소와 친해지자

> 최초에 상정된 표준 C++ 라이브러리의 주요 구성요소는 STL, iostream, locale 등입니다. 여기에는 C89 표준 라이브러리도 포함되어 있습니다.

> TR1이 도입되면서 추가된것은 스마트 포인터, 일반화 함수 포인터, 해시 기반 컨테이너, 정규 표현식 그리고 으 외의 10개 구성요소입니다.

> TR1 자체는 단순히 명세서일 뿐입니다. TR1의 기능을 사용하기 위해서는 명세를 구현한 코드를 구해야 합니다. TR1을 구현할 수 있는 자료처 중 한 군데가 바로 부스트입니다.

C++ 98에 명시된 표준 라이브러리 구성 요소를 한번 되짚어 봅시다.

* STL : 주요 구성요소로서 컨테이너, 반복자, 알고리즘, 함수 객체 등 이런 저런 컨테이너 어댑터가 있습니다.
* iostream : 사용자 정의 버퍼링, 국제화 기능이 가능한 입출력, cin, cout, cerr, clog 등의 사전정의 객체 지원
* 국제화 지원 : 여러 locale 을 활성화시킬 수 있는 기능. wchar_t 등의 타입 및 wstring 을 쓰면 유니코드 사용가능
* 수치 처리 지원 : 복수수를 나타내는 템플릿(complxe) 및 수치 배열을 나타내는 템플릿(valarray)가 해당
* 예외 클래스 계통 : 최상위 클래스인 exception 및 이것저것으로부터 갈라져 나온 파생 클래스들, logic_error, runtime_error 등이 포함
* C89의 라이브러리

TR1을 통해 명시된 새로운 구성요소는 총 14개 입니다. 모두 std 네임스페이스 안에 있습니다.

* 스마트 포인터
* tr1::function : 어떤 함수가 가진 시그니처와 호환되는 시그니처를 갖는 함수 호출성 개체(callable entity)의 표현을 가능하게 해주는 템플릿). 보통 int를 받고 string 을 반환하는 콜백 함수를 등록하도록 만들고 싶다면 `void registerCallback(std::string (int));` 라고 합니다. 여기서 `std::string(int)` 가 함수 시그니처 입니다. 이런 용도에 tr1::function 템플릿을 사용하면 registerCallback 이 훨씬 융통성 있게 됩니다. 함수 시그니처 대신 임의의 함수 호출성 개체를 받도록 만들게 함으로써, int 타입 또는 int로 변환이 가능한 어떤 타입도 전달받으며, string 타입 또는 string 으로 변환이 가능한 어떤 타입도 반환할 수 있는 그런 함수를 설정할 수 있습니다. `void registerCallback(std::tr1::function<std::string (int)> func);`
* tr1::bind : STL 바인더로 잘 쓰이고 있는 bind1st, bind2nd 와 똑같이 작동함은 물론, 훨씬 더 많은 기능이 있는 범용 바인더 입니다.

이후 TR1 나머지 구성요소는 두 종류로 나누었습니다.

* 해시 테이블 : tr1::unordered_set, tr1::unordered_multiset, ...
* 정규 표현식
* 튜플
* tr1::array : STL 스럽게 된 배열
* tr1::mem_fn : 멤버 함수 포인터를 적응시키는 용도에 쓸 수 있는, 문법적으로 천하 통일을 이룬 템플릿
* tr1::reference_wrapper 기존의 참조자가 객체처럼 행세할 수 있도록 만들어주는 템플릿
* 난수 발생
* 특수 용도의 수학 함수
* C99 호환성 확장 기능

나머지 부류는 더 세련된 템플릿 프로그래밍 기법, 이를테면 템플릿 메타 프로그래밍 같은 기법을 지원하는 기술입니다.

* 타입 특성정보(type traits) : 주어진 타입에 대한 컴파일 타임 정보를 제공하는 특성정보 클래스의 모음
* tr1::result_of : 어떤 함수 호출의 반환 타입을 추론해주는 템플릿.

<br/>

# 부자유친! 부스트를 늘 여러분 가까이에


<br/>