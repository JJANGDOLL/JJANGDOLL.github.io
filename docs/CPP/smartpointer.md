---
layout: default
title: "스마트 포인터"
nav_order: 2
parent: "CPP"
---
# Smart Pointer
{: .no_toc}

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

# 스마트 포인터란?

CPP 에서 동적으로 할당받은 메모리는 반드시 해제해줘야 합니다. 근데 이짓거리가 매우 귀찮고 복잡합니다.
스마트 포인터는 이런 어려움을 해결해줍니다.

스마트 포인터는 포인터 처럼 동작하는 클래스 템플릿으로써, 사용이 끝난 메모리를 자동을 해제해 메모리 누수로부터 프로그램의 안정성의 보장합니다.

&nbsp;

## 스마트 포인터의 종류

> C++ 11 이전
> * auto_ptr

> C++ 11 이후
> * unique_ptr
> * shared_ptr
> * weak_ptr

&nbsp;

## 스마트 포인터의 동작

보통 new 를 사용해 실제 메모리를 가르키게 초기화 한 뒤 스마트 포인터에 대입합니다.
이후 스마트 포인터의 수명이 다하면 소멸자는 delete 키워드를 사용하여 할당된 메모리를 자동 해제합니다.
따라서, new 키워드로 반환된 주소를 스마트 포인터에 대입하면 따로 메모리 해제 할 필요가 없어집니다.

&nbsp;

# unique_ptr

**단 하나의 스마트 포인터만 특정 객체를 소유할 수 있도록 합니다.**

unique_ptr 은 해당 객체의 소유권을 가지고 있을 떄에만 객체를 삭제할 수 있습니다.
unique_ptr 은 move() 를 통해 소유권을 이전할 수는 있습니다. 단, 복사는 불가능합니다.
소유권이 이전되면 더이상 이전 unique_ptr 은 해당 객체를 소유하지 않습니다.

> C++ 14 이후부터는 make_unique() 함수를 사용하여 unique_ptr 인스턴스를 생성할 수 있습니다.

&nbsp;

## shared_ptr

**하나의 특정 객체를 참조하는 스마트 포인터의 갯수를 파악합니다.**

참조하고 있는 스마트 포인터의 갯수를 Reference Count 라고 합니다.
해당 객체에 새로운 shared_ptr 이 추가될 때 마다 카운트가 1씩 증가하며, 수명이 다할 떄 마다 1씩 감소합니다.
카운터가 0이 되면 delete 되어 해제됩니다.

&nbsp;


## weak_ptr

**shared_ptr의 객체에 접근은 허용하지만, 카운트 되지는 않습니다.**

서로가 서로를 가르키는 shared_ptr 가 있다면, 이 둘은 영원히 해제되지 않을겁니다.
이런 순환 참조를 방지하기 위해 weak_ptr 를 사용합니다.

&nbsp;
